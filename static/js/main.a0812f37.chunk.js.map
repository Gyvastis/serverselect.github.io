{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["App","props","state","servers","this","setServers","fetch","then","response","json","forEach","serverList","server","push","provider","meta","setState","map","id","shortid","generate","columns","column","dataField","text","className","loading","keyField","data","cpu","amount","frequency","name","cores","ram","memory","value","unit","type","storage","connType","join","bandwidthSpeed","bandwidthLimit","price","location","city","country","bootstrap4","bordered","hover","striped","condensed","rowStyle","row","rowIndex","React","Component","Boolean","window","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"uUA+IeA,G,wDAjHb,WAAYC,GAAQ,IAAD,8BACjB,cAAMA,IACDC,MAAQ,CACXC,QAAS,IAHM,E,gEAQjBC,KAAKC,e,mCAGO,IAAD,OA/BbC,MAAM,kGACLC,MAAK,SAAAC,GAAQ,OAAIA,EAASC,UAC1BF,MAAK,SAAAC,GACJ,IAAML,EAAU,GAWhB,OATAK,EAASE,SAAQ,SAAAC,GACfA,EAAWR,QAAQO,SAAQ,SAAAE,GACzBT,EAAQU,KAAR,2BACKD,GADL,IAEEE,SAAUH,EAAWI,KAAKD,kBAKzBX,KAkBOI,MAAK,SAAAJ,GACjB,EAAKa,SAAS,CACZb,QAASA,EAAQc,KAAI,SAAAL,GAAM,kCACpBA,GADoB,IAEvBM,GAAIC,IAAQC,uB,+BA0CpB,IAAMC,EAAU,CACd,WACA,MACA,MACA,UACA,iBACA,iBACA,QAEA,YACAJ,KAAI,SAAAK,GAAM,MAAK,CACfC,UAAWD,EACXE,KAAMF,MAYR,OACE,yBAAKG,UAAU,OACb,sDACA,kBAAC,IAAD,CACEC,QAAStB,KAAKF,MAAMC,SAAW,EAC/BwB,SAAS,KACTC,KAAMxB,KAAKF,MAAMC,QAAQc,KAAI,SAAAL,GAAM,MAAK,CACtCM,GAAIN,EAAOM,GACXJ,SAAUF,EAAOE,SACjBe,IAAI,GAAD,OAAKjB,EAAOiB,IAAIC,OAAhB,aAA2BlB,EAAOiB,IAAIE,UAAtC,YAAmDnB,EAAOiB,IAAIG,KAA9D,YAAsEpB,EAAOiB,IAAII,MAAjF,UACHC,IAAI,GAAD,OAAKtB,EAAOuB,OAAOC,MAAnB,YAA4BxB,EAAOuB,OAAOE,KAA1C,YAAkDzB,EAAOuB,OAAOG,MACnEC,QAAS3B,EAAO2B,QAAQtB,KAAI,SAAAsB,GAAO,gBAAOA,EAAQT,OAAf,aAA0BS,EAAQH,MAAlC,YAA2CG,EAAQF,KAAnD,YAA2DE,EAAQD,KAAnE,YAA2EC,EAAQC,aAAYC,KAAK,OACvIC,eAAe,GAAD,OAAK9B,EAAO8B,eAAeN,MAA3B,YAAoCxB,EAAO8B,eAAeL,MACxEM,eAAgB/B,EAAO+B,eAAeP,MAAQ,EAA9B,UAAqCxB,EAAO+B,eAAeP,MAA3D,YAAoExB,EAAO+B,eAAeN,MAA1F,SAChBO,MAAM,GAAD,OAAKhC,EAAOgC,MAAMP,MAAlB,OAAyBzB,EAAOgC,MAAMR,OAE3CS,SAAS,GAAD,OAAKjC,EAAOiC,SAASC,KAArB,aAA8BlC,EAAOiC,SAASE,aAExD1B,QAASA,EACT2B,YAAY,EACZC,UAAU,EACVC,OAAO,EACPC,SAAS,EACTC,WAAW,EACXC,SA9BW,SAACC,EAAKC,Y,GA7ETC,IAAMC,YCjBJC,QACW,cAA7BC,OAAOd,SAASe,UAEe,UAA7BD,OAAOd,SAASe,UAEhBD,OAAOd,SAASe,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD6H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAM7D,MAAK,SAAA8D,GACjCA,EAAaC,kB","file":"static/js/main.a0812f37.chunk.js","sourcesContent":["import React from 'react';\n// import fs from 'fs';\n// import logo from './logo.svg';\n// import _ from 'lodash';\nimport shortid from 'shortid';\n// import firstBy from 'thenby';\nimport BootstrapTable from 'react-bootstrap-table-next';\nimport './App.css';\n\nconst readServers = () =>\n  fetch('https://raw.githubusercontent.com/rapidscrape/best-dedicated-servers/master/output/output.json')\n  .then(response => response.json())\n  .then(response => {\n    const servers = [];\n\n    response.forEach(serverList => {\n      serverList.servers.forEach(server => {\n        servers.push({\n          ...server,\n          provider: serverList.meta.provider,\n        });\n      });\n    });\n\n    return servers;\n  });\n\n// const filterPrice = 100;\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      servers: [],\n    };\n  }\n\n  componentDidMount() {\n    this.setServers();\n  }\n\n  setServers() {\n    readServers().then(servers => {\n      this.setState({\n        servers: servers.map(server => ({\n            ...server,\n            id: shortid.generate(),\n        })),\n      });\n    });\n    // .then(response => {\n    //   const availableServers = {\n    //     response\n    //       .filter(server => server.available)\n    //       .map(server => ({\n    //         ...server,\n    //         id: shortid.generate(),\n    //       };\n    //   this.setState()\n          // .map(server => ({\n          //   ...server,\n          //   meta: servers[0].meta,\n          //   price: server.price[1] !== undefined ? server.price[1] : server.price[0],\n          // }))\n          // .filter(server => server.price < filterPrice)\n          // .map(server => ({\n          //   ...server,\n          //   storage: _.sortBy(server.storage, storage => storage.type).reverse()[0],\n          // }))\n          // .sort(\n          //   firstBy((a, b) => 0)\n          //   .thenBy((a, b) => parseFloat(a.cpu.freq.replace(' Ghz')) > parseFloat(b.cpu.freq.replace(' Ghz')))\n          //   .thenBy((a, b) => a.ram.amout > b.ram.amout)\n          //   .thenBy((a, b) => a.cpu.cores > b.cpu.cores)\n          //   .thenBy((a, b) => a.storage.type === 'SSD' ? -1 : (b.storage.type === 'SSD' ? 1 : 0))\n          //   .thenBy((a, b) => (a.storage.size * a.storage.amount * (a.storage.unit === 'TB' ? 1000 : 1)) > (b.storage.size * b.storage.amount * (b.storage.unit === 'TB' ? 1000 : 1)))\n          //   .thenBy((a, b) => {\n          //     const aBandw = getRealBandwidth(a.bandwidth);\n          //     const bBandw = getRealBandwidth(b.bandwidth);\n          //     return (aBandw.amount * (aBandw.unit === 'Gbps' ? 1024 : 1)) > (bBandw.amount * (bBandw.unit === 'Gbps' ? 1024 : 1));\n          //   })\n          //   .thenBy((a, b) => a.ip > b.ip)\n          // )\n    //   });\n    // });\n  }\n\n  render() {\n    const columns = [\n      'provider',\n      'cpu',\n      'ram',\n      'storage',\n      'bandwidthSpeed',\n      'bandwidthLimit',\n      'price',\n      // 'ips',\n      'location',\n    ].map(column => ({\n      dataField: column,\n      text: column,\n    }));\n\n    // const avg = filterPrice / 3;\n    // const avg = _.mean(this.state.servers.map(server => server.price));\n\n    const rowStyle = (row, rowIndex) => {\n      // if(row.price.value && row.price > avg) return null;\n      //\n      // return { backgroundColor: 'orange' };\n    };\n\n    return (\n      <div className=\"App\">\n        <h1>Best Dedicated Servers</h1>\n        <BootstrapTable\n          loading={this.state.servers <= 0}\n          keyField='id'\n          data={this.state.servers.map(server => ({\n            id: server.id,\n            provider: server.provider,\n            cpu: `${server.cpu.amount}x ${server.cpu.frequency} ${server.cpu.name} ${server.cpu.cores} cores`,\n            ram: `${server.memory.value} ${server.memory.unit} ${server.memory.type}`,\n            storage: server.storage.map(storage => `${storage.amount}x ${storage.value} ${storage.unit} ${storage.type} ${storage.connType}`).join(' & '),\n            bandwidthSpeed: `${server.bandwidthSpeed.value} ${server.bandwidthSpeed.unit}`,\n            bandwidthLimit: server.bandwidthLimit.value > 0 ? `${server.bandwidthLimit.value} ${server.bandwidthLimit.unit}` : `âˆž`,\n            price: `${server.price.unit}${server.price.value}`,\n            // ips: '???',\n            location: `${server.location.city}, ${server.location.country}`,\n          }))}\n          columns={columns}\n          bootstrap4={true}\n          bordered={true}\n          hover={true}\n          striped={true}\n          condensed={true}\n          rowStyle={rowStyle}\n        />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}